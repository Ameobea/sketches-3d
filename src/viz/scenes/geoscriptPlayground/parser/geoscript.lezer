@precedence {
  call
  unary
  fieldAccess @left
  mul @left
  add @left
  bitAnd @left
  compare @left
  and @left
  or @left
  bitOr @left
  assign @right
  range @left
  statement
}

@skip { whitespace | LineComment }

@top Program {
  statement*
}

statement {
  ExprStatement { Expr ";"? } |
  DeclarationStatement { Identifier TypeHint? "=" Expr ";"? }
}

TypeHint { ":" Identifier }

UnaryOp { "+" | "-" | "!" }

ClosureParamList {
  Pipe commaSep<Parameter { Identifier TypeHint? }> Pipe
}

Expr {
  UnaryExpr { UnaryOp !unary Expr } |
  BinaryExpr |
  FieldAccessExpr |
  RangeExpr { Expr !range (".." | "..=") Expr } |
  CallExpr { Identifier !call "(" commaSep<FunctionArg> ")" } |
  literal |
  Identifier |
  ArrayExpr { "[" commaSep1<Expr>? "]" } |
  ClosureExpr { (LogicalOrOp TypeHint? ClosureBody) | (ClosureParamList TypeHint? ClosureBody) } |
  ParenthesizedExpr { "(" Expr ")" }
}

FunctionArg {
  Expr | Kwarg { Identifier "=" Expr }
}

BinaryExpr {
  Expr !add ("+" | "-") Expr |
  Expr !mul ("*" | "/" | "%") Expr |
  Expr !bitAnd "&" Expr |
  Expr !bitOr Pipe Expr |
  Expr !bitOr "->" Expr |
  Expr !compare CompareOp Expr |
  Expr !and LogicalAndOp Expr |
  Expr !or LogicalOrOp Expr
}

FieldAccessExpr {
  Expr !fieldAccess "." Identifier
}

ClosureBody {
  Expr | ("{" statement* "}" )
}

literal { Float | Integer | BoolLiteral }

commaSep<Expr> { commaSep1<Expr>? }

commaSep1<Expr> { Expr ("," Expr?)* }

@external tokens literalTokens from "./tokens" { Float }

@tokens {
  whitespace { $[ \t\r\n] }

  Pipe { "|" }
  LogicalAndOp { "&&" }
  LogicalOrOp { "||" }
  CompareOp { "<" | ">" | ">=" | "<=" | "==" | "!=" }

  BoolLiteral { "true" | "false" }
  Integer { $[0-9]+ }

  LineComment[isolate] { "//" ![\n]* }

  @precedence { LineComment, "/" }

  Identifier { $[a-zA-Z_] $[a-zA-Z0-9_]* }

  @precedence { BoolLiteral, Identifier }

  "[" "]" "{" "}" "(" ")"
  ":" ","
  "=" ".." "..="
  "&" "!" "->" ";"
}

@external propSource geoscriptHighlighting from "./highlight"

@detectDelim
